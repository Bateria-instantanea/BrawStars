# -*- coding: utf-8 -*-
"""Analise Braw Stars VersÃ£o Final 2.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SYnB4ktrsYZbS6v_GI48NuEVOl5do0UQ
"""

!pip install requests pandas openpyxl scikit-learn -q

import requests
import pandas as pd
import json
import time
from datetime import datetime
from collections import defaultdict
from google.colab import files, drive
import os
import math
from sklearn.cluster import KMeans
import numpy as np
import random

# Verificar IP do Colab
print("="*70)
print("ðŸŒ DETECTANDO IP DO GOOGLE COLAB...")
print("="*70)
try:
    ip_response = requests.get('https://api.ipify.org?format=json', timeout=5)
    current_ip = ip_response.json()['ip']
    print(f"\nâœ… IP ATUAL DO COLAB: {current_ip}\n")
    print("="*70)
    print("ðŸ“‹ INSTRUÃ‡Ã•ES PARA CRIAR O TOKEN:")
    print("="*70)
    print("1. Acesse: https://developer.brawlstars.com/#/login")
    print("2. FaÃ§a login com Supercell ID")
    print("3. VÃ¡ em 'My Account' â†’ 'Create New Key'")
    print(f"4. Em 'Allowed IP addresses' cole: {current_ip}")
    print("5. Clique em 'Create Key'")
    print("6. Copie o token gerado e cole abaixo")
    print("="*70)
    print(f"ðŸ’¡ DICA: Use 3-5 tokens separados por vÃ­rgula para maior velocidade")
    print("="*70)
except:
    print("âš ï¸  NÃ£o foi possÃ­vel detectar o IP automaticamente")

# Montar Google Drive
print("\nðŸ”— Montando Google Drive...")
drive.mount('/content/drive')

# ConfiguraÃ§Ãµes
print("\n" + "="*70)
API_TOKENS = input("ðŸ”‘ COLE SEU(S) TOKEN(S) AQUI (separados por vÃ­rgula): ").split(',')
API_TOKENS = [t.strip() for t in API_TOKENS]
current_token_index = 0

print("="*70)
print(f"âœ… {len(API_TOKENS)} token(s) configurado(s)!")
print("ðŸŽ¯ META: 1.000.000 DE BATALHAS")
print("="*70 + "\n")

def get_current_token():
    """Retorna o token atual"""
    return API_TOKENS[current_token_index % len(API_TOKENS)]

def rotate_token():
    """Alterna para o prÃ³ximo token"""
    global current_token_index
    current_token_index += 1

def get_headers():
    return {
        'Authorization': f'Bearer {get_current_token()}',
        'Accept': 'application/json'
    }

SAVE_FOLDER = "/content/drive/MyDrive/BrawlStarsData_1M"
os.makedirs(SAVE_FOLDER, exist_ok=True)

# Modos de jogo
GAME_MODES = {
    'gemGrab': 'Pique-Gema',
    'brawlBall': 'Futebraw',
    'heist': 'Roubo',
    'bounty': 'CaÃ§a Estrelas',
    'hotZone': 'Zona EstratÃ©gica',
    'knockout': 'Nocaute'
}

# EstatÃ­sticas globais
stats = {
    'total_battles': 0,
    'players_processed': 0,
    'errors': 0,
    'start_time': time.time(),
    'regions_used': set()
}

brawler_stats = defaultdict(lambda: {
    'battles': 0,
    'wins': 0,
    'picks': 0,
    'modes': defaultdict(lambda: {'battles': 0, 'wins': 0, 'picks': 0}),
    'star_powers': defaultdict(lambda: {'battles': 0, 'wins': 0, 'picks': 0}),
    'gadgets': defaultdict(lambda: {'battles': 0, 'wins': 0, 'picks': 0})
})

mode_stats = defaultdict(lambda: defaultdict(lambda: {'battles': 0, 'wins': 0, 'picks': 0}))
total_picks_per_mode = defaultdict(int)

def fetch_ranking_players(region='global', limit=200):
    """Busca jogadores do ranking com retry"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            url = f'https://api.brawlstars.com/v1/rankings/{region}/players?limit={limit}'
            response = requests.get(url, headers=get_headers(), timeout=10)

            if response.status_code == 403:
                if len(API_TOKENS) > 1:
                    rotate_token()
                    continue
                return []

            if response.status_code == 429:
                time.sleep(2)
                if len(API_TOKENS) > 1:
                    rotate_token()
                continue

            if response.status_code == 200:
                data = response.json()
                return data.get('items', [])

        except Exception as e:
            if attempt == max_retries - 1:
                return []
            time.sleep(1)

    return []

def fetch_club_members(club_tag):
    """Busca membros de um clube"""
    max_retries = 2
    for attempt in range(max_retries):
        try:
            clean_tag = club_tag.replace('#', '%23')
            url = f'https://api.brawlstars.com/v1/clubs/{clean_tag}/members'
            response = requests.get(url, headers=get_headers(), timeout=10)

            if response.status_code == 429:
                time.sleep(1)
                if len(API_TOKENS) > 1:
                    rotate_token()
                continue

            if response.status_code == 403:
                if len(API_TOKENS) > 1:
                    rotate_token()
                    continue
                return []

            if response.status_code == 200:
                data = response.json()
                return data.get('items', [])

        except:
            if attempt == max_retries - 1:
                return []
            time.sleep(0.5)

    return []

def fetch_top_clubs(region='global', limit=200):
    """Busca top clubes de uma regiÃ£o"""
    max_retries = 2
    for attempt in range(max_retries):
        try:
            url = f'https://api.brawlstars.com/v1/rankings/{region}/clubs?limit={limit}'
            response = requests.get(url, headers=get_headers(), timeout=10)

            if response.status_code == 429:
                time.sleep(1)
                if len(API_TOKENS) > 1:
                    rotate_token()
                continue

            if response.status_code == 403:
                if len(API_TOKENS) > 1:
                    rotate_token()
                    continue
                return []

            if response.status_code == 200:
                data = response.json()
                return data.get('items', [])

        except:
            if attempt == max_retries - 1:
                return []
            time.sleep(0.5)

    return []

def fetch_player_battlelog(player_tag):
    """Busca histÃ³rico de batalhas com retry"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            clean_tag = player_tag.replace('#', '%23')
            url = f'https://api.brawlstars.com/v1/players/{clean_tag}/battlelog'
            response = requests.get(url, headers=get_headers(), timeout=10)

            if response.status_code == 429:
                time.sleep(1)
                if len(API_TOKENS) > 1:
                    rotate_token()
                continue

            if response.status_code == 403:
                if len(API_TOKENS) > 1:
                    rotate_token()
                    continue
                return None

            if response.status_code == 200:
                data = response.json()
                return data.get('items', [])

        except Exception as e:
            if attempt == max_retries - 1:
                return None
            time.sleep(0.5)

    return None

def process_battle(battle):
    """Processa uma batalha e atualiza estatÃ­sticas"""
    mode = battle.get('event', {}).get('mode')
    if not mode or mode not in GAME_MODES:
        return

    mode_name = GAME_MODES[mode]
    battle_data = battle.get('battle', {})
    result = battle_data.get('result')
    teams = battle_data.get('teams', [])

    if not teams:
        return

    stats['total_battles'] += 1

    for team in teams:
        for player in team:
            brawler = player.get('brawler', {})
            brawler_name = brawler.get('name')

            if not brawler_name:
                continue

            is_win = result == 'victory'

            # Taxa de uso (picks)
            brawler_stats[brawler_name]['picks'] += 1
            total_picks_per_mode[mode_name] += 1

            # Stats gerais
            brawler_stats[brawler_name]['battles'] += 1
            if is_win:
                brawler_stats[brawler_name]['wins'] += 1

            # Stats por modo
            brawler_stats[brawler_name]['modes'][mode_name]['picks'] += 1
            brawler_stats[brawler_name]['modes'][mode_name]['battles'] += 1
            if is_win:
                brawler_stats[brawler_name]['modes'][mode_name]['wins'] += 1

            # Stats do modo (para ranking)
            mode_stats[mode_name][brawler_name]['picks'] += 1
            mode_stats[mode_name][brawler_name]['battles'] += 1
            if is_win:
                mode_stats[mode_name][brawler_name]['wins'] += 1

            # Star Powers
            for sp in brawler.get('starPowers', []):
                sp_name = sp.get('name')
                if sp_name:
                    brawler_stats[brawler_name]['star_powers'][sp_name]['picks'] += 1
                    brawler_stats[brawler_name]['star_powers'][sp_name]['battles'] += 1
                    if is_win:
                        brawler_stats[brawler_name]['star_powers'][sp_name]['wins'] += 1

            # Gadgets
            for gadget in brawler.get('gadgets', []):
                gadget_name = gadget.get('name')
                if gadget_name:
                    brawler_stats[brawler_name]['gadgets'][gadget_name]['picks'] += 1
                    brawler_stats[brawler_name]['gadgets'][gadget_name]['battles'] += 1
                    if is_win:
                        brawler_stats[brawler_name]['gadgets'][gadget_name]['wins'] += 1

def calculate_winrate(wins, battles):
    """Calcula winrate"""
    return round((wins / battles * 100), 2) if battles > 0 else 0

def calculate_pickrate(picks, total_picks):
    """Calcula taxa de uso"""
    return round((picks / total_picks * 100), 2) if total_picks > 0 else 0

def calculate_ai_score(winrate_decimal, battles, total_battles):

    # Fator 1: Winrate (50%)
    score_winrate = winrate_decimal * 0.5

    # Fator 2: Confiabilidade logarÃ­tmica (30%)
    confidence = min(1.0, math.log(battles + 1) / math.log(1000))
    score_confidence = confidence * 0.3

    # Fator 3: Desvio da mÃ©dia (20%)
    avg_winrate = 0.5
    deviation = abs(winrate_decimal - avg_winrate)
    score_deviation = deviation * 0.2

    ai_score = score_winrate + score_confidence + score_deviation

    return {
        'ai_score': round(ai_score * 100, 2),
        'confidence': round(confidence * 100, 1)
    }

def cluster_star_powers(brawler_name, brawler_data):
    """ClusterizaÃ§Ã£o K-Means para Star Powers"""
    sp_data = []
    sp_names = []

    for sp_name, sp_stats in brawler_data['star_powers'].items():
        if sp_stats['battles'] >= 10:
            winrate = calculate_winrate(sp_stats['wins'], sp_stats['battles'])
            sp_data.append([
                sp_stats['picks'],
                sp_stats['battles'],
                sp_stats['wins'],
                winrate
            ])
            sp_names.append(sp_name)

    if len(sp_data) == 0:
        return {}

    sp_clusters = {}

    if len(sp_data) >= 2:
        sp_array = np.array(sp_data)

        from sklearn.preprocessing import StandardScaler
        scaler = StandardScaler()
        sp_normalized = scaler.fit_transform(sp_array)

        n_clusters = min(2, len(sp_data))
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        labels = kmeans.fit_predict(sp_normalized)

        for idx, label in enumerate(labels):
            if label not in sp_clusters:
                sp_clusters[label] = []
            sp_clusters[label].append({
                'name': sp_names[idx],
                'picks': sp_data[idx][0],
                'battles': sp_data[idx][1],
                'wins': sp_data[idx][2],
                'winrate': sp_data[idx][3]
            })

        for cluster_id in sp_clusters:
            sp_clusters[cluster_id].sort(key=lambda x: x['picks'], reverse=True)

    elif len(sp_data) == 1:
        sp_clusters[0] = [{
            'name': sp_names[0],
            'picks': sp_data[0][0],
            'battles': sp_data[0][1],
            'wins': sp_data[0][2],
            'winrate': sp_data[0][3]
        }]

    return sp_clusters

def cluster_gadgets(brawler_name, brawler_data):
    """ClusterizaÃ§Ã£o K-Means para Gadgets"""
    gadget_data = []
    gadget_names = []

    for gadget_name, gadget_stats in brawler_data['gadgets'].items():
        if gadget_stats['battles'] >= 10:
            winrate = calculate_winrate(gadget_stats['wins'], gadget_stats['battles'])
            gadget_data.append([
                gadget_stats['picks'],
                gadget_stats['battles'],
                gadget_stats['wins'],
                winrate
            ])
            gadget_names.append(gadget_name)

    if len(gadget_data) == 0:
        return {}

    gadget_clusters = {}

    if len(gadget_data) >= 2:
        gadget_array = np.array(gadget_data)

        from sklearn.preprocessing import StandardScaler
        scaler = StandardScaler()
        gadget_normalized = scaler.fit_transform(gadget_array)

        n_clusters = min(2, len(gadget_data))
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        labels = kmeans.fit_predict(gadget_normalized)

        for idx, label in enumerate(labels):
            if label not in gadget_clusters:
                gadget_clusters[label] = []
            gadget_clusters[label].append({
                'name': gadget_names[idx],
                'picks': gadget_data[idx][0],
                'battles': gadget_data[idx][1],
                'wins': gadget_data[idx][2],
                'winrate': gadget_data[idx][3]
            })

        for cluster_id in gadget_clusters:
            gadget_clusters[cluster_id].sort(key=lambda x: x['picks'], reverse=True)

    elif len(gadget_data) == 1:
        gadget_clusters[0] = [{
            'name': gadget_names[0],
            'picks': gadget_data[0][0],
            'battles': gadget_data[0][1],
            'wins': gadget_data[0][2],
            'winrate': gadget_data[0][3]
        }]

    return gadget_clusters

def get_all_brawlers_by_mode(mode_name):
    """Retorna TODOS os brawlers de um modo com IA score"""
    brawlers = []
    total_picks = sum(data['picks'] for data in mode_stats[mode_name].values())

    for brawler_name, data in mode_stats[mode_name].items():
        if data['battles'] > 0:
            winrate = calculate_winrate(data['wins'], data['battles'])
            pickrate = calculate_pickrate(data['picks'], total_picks)
            ai_data = calculate_ai_score(winrate/100, data['battles'], stats['total_battles'])

            brawlers.append({
                'brawler': brawler_name,
                'winrate': winrate,
                'pickrate': pickrate,
                'picks': data['picks'],
                'battles': data['battles'],
                'wins': data['wins'],
                'ai_score': ai_data['ai_score'],
                'confidence': ai_data['confidence']
            })

    brawlers.sort(key=lambda x: x['ai_score'], reverse=True)
    return brawlers

def save_results():
    """Salva todos os resultados com anÃ¡lises completas"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

    print("\nðŸ’¾ Salvando resultados completos...")

    # 1. TODOS os brawlers com stats gerais
    brawler_data = []
    total_picks_global = sum(data['picks'] for data in brawler_stats.values())

    for brawler_name, data in brawler_stats.items():
        winrate = calculate_winrate(data['wins'], data['battles'])
        pickrate = calculate_pickrate(data['picks'], total_picks_global)
        ai_data = calculate_ai_score(winrate/100, data['battles'], stats['total_battles'])

        brawler_data.append({
            'Brawler': brawler_name,
            'Total_Batalhas': data['battles'],
            'Total_Vitorias': data['wins'],
            'Winrate_Geral': winrate,
            'Taxa_Uso': pickrate,
            'Total_Picks': data['picks'],
            'Score_IA': ai_data['ai_score'],
            'Confianca': ai_data['confidence']
        })

    df_brawlers = pd.DataFrame(brawler_data)
    df_brawlers = df_brawlers.sort_values('Score_IA', ascending=False)

    # 2. ClusterizaÃ§Ã£o de Star Powers
    print("ðŸ¤– Aplicando clusterizaÃ§Ã£o K-Means em Star Powers...")
    sp_cluster_data = []

    for brawler_name, data in brawler_stats.items():
        if data['battles'] >= 50:
            sp_clusters = cluster_star_powers(brawler_name, data)

            for cluster_id, items in sp_clusters.items():
                for item in items:
                    sp_cluster_data.append({
                        'Brawler': brawler_name,
                        'Star_Power': item['name'],
                        'Cluster': cluster_id,
                        'Picks': item['picks'],
                        'Batalhas': item['battles'],
                        'Vitorias': item['wins'],
                        'Winrate': item['winrate'],
                        'Categoria': 'Principal' if cluster_id == 0 else 'Alternativo'
                    })

    df_sp_clusters = pd.DataFrame(sp_cluster_data)

    # 3. ClusterizaÃ§Ã£o de Gadgets
    print("ðŸ¤– Aplicando clusterizaÃ§Ã£o K-Means em Gadgets...")
    gadget_cluster_data = []

    for brawler_name, data in brawler_stats.items():
        if data['battles'] >= 50:
            gadget_clusters = cluster_gadgets(brawler_name, data)

            for cluster_id, items in gadget_clusters.items():
                for item in items:
                    gadget_cluster_data.append({
                        'Brawler': brawler_name,
                        'Gadget': item['name'],
                        'Cluster': cluster_id,
                        'Picks': item['picks'],
                        'Batalhas': item['battles'],
                        'Vitorias': item['wins'],
                        'Winrate': item['winrate'],
                        'Categoria': 'Principal' if cluster_id == 0 else 'Alternativo'
                    })

    df_gadget_clusters = pd.DataFrame(gadget_cluster_data)

    # 4. TODOS os acessÃ³rios detalhados
    accessories_data = []
    for brawler_name, data in brawler_stats.items():
        for sp_name, sp_data in data['star_powers'].items():
            accessories_data.append({
                'Brawler': brawler_name,
                'Tipo': 'Star Power',
                'Nome': sp_name,
                'Picks': sp_data['picks'],
                'Batalhas': sp_data['battles'],
                'Vitorias': sp_data['wins'],
                'Winrate': calculate_winrate(sp_data['wins'], sp_data['battles'])
            })

        for gadget_name, gadget_data in data['gadgets'].items():
            accessories_data.append({
                'Brawler': brawler_name,
                'Tipo': 'Gadget',
                'Nome': gadget_name,
                'Picks': gadget_data['picks'],
                'Batalhas': gadget_data['battles'],
                'Vitorias': gadget_data['wins'],
                'Winrate': calculate_winrate(gadget_data['wins'], gadget_data['battles'])
            })

    df_accessories = pd.DataFrame(accessories_data)

    # Salvar Excel COMPLETO
    excel_path = f"{SAVE_FOLDER}/brawl_stats_1M_{timestamp}.xlsx"
    print("ðŸ“Š Gerando Excel com mÃºltiplas abas...")

    with pd.ExcelWriter(excel_path, engine='openpyxl') as writer:
        # Aba 1: Geral
        df_brawlers.to_excel(writer, sheet_name='1_Brawlers_Geral', index=False)

        # Aba 2: Clusters de Star Powers
        if not df_sp_clusters.empty:
            df_sp_clusters.to_excel(writer, sheet_name='2_StarPower_Clusters', index=False)

        # Aba 3: Clusters de Gadgets
        if not df_gadget_clusters.empty:
            df_gadget_clusters.to_excel(writer, sheet_name='3_Gadget_Clusters', index=False)

        # Aba 4: Todos os acessÃ³rios
        df_accessories.to_excel(writer, sheet_name='4_Acessorios_Completo', index=False)

        # Abas 5+: TODOS os brawlers por modo
        for mode_name in GAME_MODES.values():
            if mode_name in mode_stats:
                all_brawlers = get_all_brawlers_by_mode(mode_name)
                df_mode = pd.DataFrame(all_brawlers)
                sheet_name = f"5_{mode_name.replace(' ', '_')}"[:31]
                df_mode.to_excel(writer, sheet_name=sheet_name, index=False)

    print(f"âœ… Excel salvo: {excel_path}")

    # Salvar JSON completo
    json_data = {
        'metadata': {
            'total_battles': stats['total_battles'],
            'players_processed': stats['players_processed'],
            'errors': stats['errors'],
            'collection_date': datetime.now().isoformat(),
            'duration_seconds': int(time.time() - stats['start_time']),
            'regions_used': list(stats['regions_used']),
            'target': '1M battles'
        },
        'brawler_stats': dict(brawler_stats),
        'mode_stats': {mode: dict(brawlers) for mode, brawlers in mode_stats.items()},
        'star_power_clusters': sp_cluster_data,
        'gadget_clusters': gadget_cluster_data
    }

    json_path = f"{SAVE_FOLDER}/brawl_data_1M_{timestamp}.json"
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(json_data, f, indent=2, ensure_ascii=False, default=str)

    print(f"âœ… JSON salvo: {json_path}")

    return excel_path, json_path

def main():
    """FunÃ§Ã£o principal otimizada para 1M de batalhas"""
    print("ðŸŽ® COLETOR BRAWL STARS - 1 MILHÃƒO DE BATALHAS\n")
    print("="*70)

    print("\nðŸŒŽ Coletando jogadores de TODAS as regiÃµes globais...")
    print("="*70)

    # RegiÃµes principais
    main_regions = ['global', 'BR', 'US', 'CN', 'RU', 'TR', 'MX', 'ES', 'FR', 'DE', 'GB', 'JP', 'KR']

    # RegiÃµes secundÃ¡rias
    secondary_regions = [
        'AR', 'CL', 'CO', 'PE', 'IT', 'PL', 'NL', 'TW', 'HK', 'SG', 'TH', 'ID', 'MY', 'PH',
        'AU', 'NZ', 'CA', 'SA', 'AE', 'IN', 'ZA', 'EG', 'VE', 'EC', 'PT', 'BE', 'CH', 'AT',
        'NO', 'SE', 'DK', 'FI', 'VN'
    ]

    all_players = []
    all_player_tags = set()
    target_players = 80000

    print(f"ðŸŽ¯ Meta: {target_players:,} jogadores Ãºnicos")
    print(f"ðŸ“Š EstratÃ©gia 1: Rankings de jogadores")
    print(f"ðŸ“Š EstratÃ©gia 2: Membros de clubes top\n")

    # FASE 1: Buscar jogadores dos rankings
    print("ðŸ” FASE 1: Coletando rankings de jogadores...")
    for region in main_regions + secondary_regions:
        if len(all_player_tags) >= target_players:
            break

        try:
            players = fetch_ranking_players(region, 200)
            if players:
                for player in players:
                    tag = player.get('tag')
                    if tag and tag not in all_player_tags:
                        all_player_tags.add(tag)
                        all_players.append(player)

                stats['regions_used'].add(region)

                if len(all_player_tags) % 5000 == 0:
                    print(f"   ðŸ“Š {len(all_player_tags):,} jogadores Ãºnicos | {len(stats['regions_used'])} regiÃµes")

            time.sleep(0.1)
        except:
            continue

    print(f"\nâœ… Fase 1 completa: {len(all_player_tags):,} jogadores")

    # FASE 2: Buscar membros de clubes top (para pegar mais jogadores)
    if len(all_player_tags) < target_players:
        print(f"\nðŸ” FASE 2: Coletando membros de clubes top...")
        clubs_processed = 0
        max_clubs_per_region = 50

        for region in main_regions + secondary_regions:
            if len(all_player_tags) >= target_players:
                break

            try:
                clubs = fetch_top_clubs(region, 200)
                if clubs:
                    for club in clubs[:max_clubs_per_region]:
                        if len(all_player_tags) >= target_players:
                            break

                        club_tag = club.get('tag')
                        if club_tag:
                            members = fetch_club_members(club_tag)
                            if members:
                                for member in members:
                                    tag = member.get('tag')
                                    if tag and tag not in all_player_tags:
                                        all_player_tags.add(tag)
                                        all_players.append(member)

                                clubs_processed += 1

                                if len(all_player_tags) % 5000 == 0:
                                    print(f"   ðŸ“Š {len(all_player_tags):,} jogadores | {clubs_processed} clubes")

                            time.sleep(0.08)

                time.sleep(0.1)
            except:
                continue

        print(f"\nâœ… Fase 2 completa: {len(all_player_tags):,} jogadores | {clubs_processed} clubes processados")

    # Embaralhar para distribuiÃ§Ã£o aleatÃ³ria
    random.shuffle(all_players)

    print(f"\n{'='*70}")
    print(f"âœ… Total coletado: {len(all_player_tags):,} jogadores Ãºnicos")
    print(f"ðŸŒ RegiÃµes: {len(stats['regions_used'])}")
    print(f"ðŸŽ¯ Meta: 1.000.000 batalhas")
    print(f"ðŸ“Š Estimativa: {len(all_players) * 15:,} batalhas (mÃ©dia 15 por jogador)")
    print(f"{'='*70}")

    if not all_players:
        print("âŒ Erro ao buscar jogadores!")
        return

    print(f"\nðŸš€ Iniciando mega-coleta...\n")
    print("ðŸ¤– IA: Score Ponderado + K-Means (Star Powers & Gadgets)")
    print("="*70 + "\n")

    target_battles = 1000000
    checkpoint_interval = 50000
    last_checkpoint = 0

    for idx, player in enumerate(all_players):
        if stats['total_battles'] >= target_battles:
            print("\nðŸŽ‰ META DE 1 MILHÃƒO ATINGIDA!")
            break

        if idx % 1000 == 0 and idx > 0:
            print(f"\n{'='*70}")
            print(f"ðŸ“Š PROGRESSO:")
            print(f"   Jogadores: {idx:,} / {len(all_players):,} ({idx/len(all_players)*100:.1f}%)")
            print(f"   Batalhas: {stats['total_battles']:,} / 1,000,000 ({stats['total_battles']/10000:.1f}%)")
            elapsed = time.time() - stats['start_time']
            speed = stats['total_battles'] / elapsed if elapsed > 0 else 0
            remaining = (target_battles - stats['total_battles']) / speed if speed > 0 else 0
            print(f"   Velocidade: {speed:.1f} batalhas/seg")
            print(f"   ETA: {int(remaining/3600)}h {int((remaining%3600)/60)}min")
            print(f"   Erros: {stats['errors']}")
            print(f"{'='*70}")

        battlelog = fetch_player_battlelog(player.get('tag', ''))

        if not battlelog:
            stats['errors'] += 1
            time.sleep(0.1)
            continue

        for battle in battlelog:
            if stats['total_battles'] >= target_battles:
                break
            process_battle(battle)

        stats['players_processed'] += 1

        if stats['total_battles'] - last_checkpoint >= checkpoint_interval:
            print(f"\nðŸ’¾ CHECKPOINT: {stats['total_battles']:,} batalhas")
            last_checkpoint = stats['total_battles']

        time.sleep(0.03)

    print("\n\n" + "="*70)
    print(f"âœ… COLETA FINALIZADA!")
    print(f"ðŸ“Š Batalhas: {stats['total_battles']:,}")
    print(f"ðŸ‘¥ Jogadores: {stats['players_processed']:,}")
    print(f"ðŸŒ RegiÃµes: {len(stats['regions_used'])}")
    print(f"âŒ Erros: {stats['errors']}")
    elapsed_total = int(time.time() - stats['start_time'])
    print(f"â±ï¸  Tempo: {elapsed_total//3600}h {(elapsed_total%3600)//60}min")
    print("="*70)

    excel_path, json_path = save_results()

    print("\nðŸŽ‰ DADOS SALVOS NO GOOGLE DRIVE!")
    print(f"ðŸ“ Pasta: {SAVE_FOLDER}")
    print(f"ðŸ“Š Excel: {os.path.basename(excel_path)}")
    print(f"ðŸ“„ JSON: {os.path.basename(json_path)}")

    print("\nðŸ¤– ANÃLISES INCLUÃDAS:")
    print("  âœ… TODOS os brawlers de todos os modos")
    print("  âœ… Taxa de uso (pickrate) completa")
    print("  âœ… ClusterizaÃ§Ã£o K-Means de Star Powers")
    print("  âœ… ClusterizaÃ§Ã£o K-Means de Gadgets")
    print("  âœ… Score IA para todos os brawlers")
    print("  âœ… Dados de mÃºltiplas regiÃµes (sem viÃ©s)")
    print(f"\nðŸ“Š Base: {stats['total_battles']:,} batalhas analisadas!")
    print("="*70)

if __name__ == "__main__":
    main()

from google.colab import drive
drive.mount('/content/drive')

!pip install pandas openpyxl matplotlib seaborn scikit-learn -q

import json
import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import numpy as np
from sklearn.cluster import KMeans
from collections import defaultdict

print("="*70)
print("ðŸ† ANÃLISE COMPLETA - RANKINGS + TROFÃ‰US + USO")
print("="*70)

# Montar Google Drive
print("\nðŸ”— Montando Google Drive...")
drive.mount('/content/drive')

# Carregar dados
DATA_FOLDER = "/content/drive/MyDrive/BrawlStarsData_1M"
files_list = [f for f in os.listdir(DATA_FOLDER) if f.endswith('.json')]
latest_file = sorted(files_list)[-1]
json_path = os.path.join(DATA_FOLDER, latest_file)

print(f"ðŸ“¥ Carregando: {latest_file}\n")
with open(json_path, 'r', encoding='utf-8') as f:
    data = json.load(f)

mode_stats = data.get('mode_stats', {})
brawler_stats = data.get('brawler_stats', {})
metadata = data.get('metadata', {})

print(f"âœ… Dados carregados!")
print(f"ðŸ“Š Total de batalhas: {metadata.get('total_battles', 0):,}")
print(f"ðŸŽ® Modos disponÃ­veis: {len(mode_stats)}")

# Modos alvo
TARGET_MODES = ['Pique-Gema', 'Futebraw', 'Roubo', 'Nocaute', 'CaÃ§a Estrelas', 'Zona EstratÃ©gica']

# ============================================================================
# ANÃLISE DE TROFÃ‰US DOS JOGADORES
# ============================================================================

print("\n" + "="*70)
print("ðŸ† ANALISANDO DISTRIBUIÃ‡ÃƒO DE TROFÃ‰US DOS JOGADORES...")
print("="*70)

# Verificar se hÃ¡ dados de trofÃ©us nos battles
trophy_ranges = {
    '0-10k': 0,
    '10k-20k': 0,
    '20k-50k': 0,
    '50k-100k': 0,
    '100k+': 0
}

# Nota: Como os dados vÃªm do battlelog, nÃ£o temos acesso direto aos trofÃ©us totais
# Vamos usar uma estimativa baseada no metadata de jogadores processados
total_players = metadata.get('players_processed', 0)

print(f"\nðŸ“Š Jogadores processados: {total_players:,}")
print("\nâš ï¸  NOTA: Dados de trofÃ©us individuais nÃ£o estÃ£o disponÃ­veis no battlelog.")
print("Para obter essa informaÃ§Ã£o, seria necessÃ¡rio fazer requisiÃ§Ãµes adicionais")
print("Ã  API para cada jogador (/players/{tag}), o que aumentaria muito o tempo.")
print("\nðŸ’¡ Alternativa implementada: AnÃ¡lise por regiÃ£o e ranking jÃ¡ dÃ¡ insights")
print("sobre o nÃ­vel dos jogadores (todos sÃ£o do top ranking).")

# ============================================================================
# TOP 10 BRAWLERS MAIS USADOS (GERAL)
# ============================================================================

print("\n" + "="*70)
print("ðŸ“Š CALCULANDO TOP 10 BRAWLERS MAIS USADOS...")
print("="*70)

usage_ranking = []
total_picks_global = 0

for brawler_name, stats in brawler_stats.items():
    picks = stats.get('picks', 0)
    battles = stats.get('battles', 0)
    wins = stats.get('wins', 0)

    total_picks_global += picks

    if battles > 0:
        winrate = (wins / battles * 100)
        usage_ranking.append({
            'Brawler': brawler_name,
            'Total_Picks': picks,
            'Batalhas': battles,
            'Winrate': round(winrate, 2)
        })

# Calcular pickrate
for brawler in usage_ranking:
    pickrate = (brawler['Total_Picks'] / total_picks_global * 100) if total_picks_global > 0 else 0
    brawler['Pickrate'] = round(pickrate, 2)

# Ordenar por picks
usage_ranking.sort(key=lambda x: x['Total_Picks'], reverse=True)
top_10_usage = usage_ranking[:10]

print(f"\nðŸ”¥ TOP 10 BRAWLERS MAIS USADOS:")
print("="*70)
for i, brawler in enumerate(top_10_usage, 1):
    print(f"{i:2}. {brawler['Brawler']:15} | Pickrate: {brawler['Pickrate']:5.2f}% | WR: {brawler['Winrate']:5.2f}% | Picks: {brawler['Total_Picks']:,}")

# ============================================================================
# PROCESSAR RANKINGS POR MODO
# ============================================================================

print("\n" + "="*70)
print("ðŸ“Š PROCESSANDO RANKINGS POR MODO...")
print("="*70)

all_rankings = {}

for mode_name in TARGET_MODES:
    if mode_name not in mode_stats:
        print(f"âš ï¸  {mode_name}: NÃ£o encontrado")
        continue

    mode_data = mode_stats[mode_name]
    brawlers_list = []

    for brawler_name, stats in mode_data.items():
        battles = stats.get('battles', 0)
        wins = stats.get('wins', 0)
        picks = stats.get('picks', 0)

        if battles >= 100:
            winrate = (wins / battles * 100) if battles > 0 else 0

            brawlers_list.append({
                'Brawler': brawler_name,
                'Batalhas': battles,
                'Vitorias': wins,
                'Winrate': round(winrate, 2),
                'Picks': picks
            })

    brawlers_list.sort(key=lambda x: x['Winrate'], reverse=True)

    all_rankings[mode_name] = {
        'top_15': brawlers_list[:15],
        'bottom_15': brawlers_list[-15:][::-1],
        'all': brawlers_list
    }

    print(f"âœ… {mode_name}: {len(brawlers_list)} brawlers analisados")

# ============================================================================
# CLUSTERIZAÃ‡ÃƒO K-MEANS POR MODO
# ============================================================================

print("\n" + "="*70)
print("ðŸ¤– APLICANDO CLUSTERIZAÃ‡ÃƒO K-MEANS...")
print("="*70)

cluster_results = {}

for mode_name, rankings in all_rankings.items():
    brawlers = rankings['all']

    if len(brawlers) < 10:
        continue

    features = np.array([[b['Winrate'], b['Picks'], b['Batalhas']] for b in brawlers])

    from sklearn.preprocessing import StandardScaler
    scaler = StandardScaler()
    features_normalized = scaler.fit_transform(features)

    kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
    labels = kmeans.fit_predict(features_normalized)

    cluster_winrates = {}
    for i in range(3):
        cluster_brawlers = [b for idx, b in enumerate(brawlers) if labels[idx] == i]
        avg_wr = np.mean([b['Winrate'] for b in cluster_brawlers])
        cluster_winrates[i] = avg_wr

    sorted_clusters = sorted(cluster_winrates.items(), key=lambda x: x[1], reverse=True)

    cluster_map = {sorted_clusters[0][0]: 'Top Tier',
                   sorted_clusters[1][0]: 'Mid Tier',
                   sorted_clusters[2][0]: 'Low Tier'}

    for idx, brawler in enumerate(brawlers):
        brawler['Tier'] = cluster_map[labels[idx]]

    cluster_results[mode_name] = {
        'brawlers': brawlers,
        'cluster_map': cluster_map
    }

    print(f"âœ… {mode_name}: Clusters identificados")

# ============================================================================
# CRIAR VISUALIZAÃ‡Ã•ES - GRÃFICOS MELHORADOS
# ============================================================================

print("\n" + "="*70)
print("ðŸ“Š GERANDO VISUALIZAÃ‡Ã•ES MELHORADAS...")
print("="*70)

plt.style.use('dark_background')

for mode_name in TARGET_MODES:
    if mode_name not in all_rankings:
        continue

    rankings = all_rankings[mode_name]
    top_15 = rankings['top_15']
    bottom_15 = rankings['bottom_15']

    if len(top_15) == 0 or len(bottom_15) == 0:
        continue

    # CRIAR FIGURA COM GRÃFICOS E TABELAS
    fig = plt.figure(figsize=(24, 16))
    gs = fig.add_gridspec(3, 2, height_ratios=[2, 1.2, 1.2], hspace=0.3, wspace=0.3)

    # ===== GRÃFICOS =====
    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[0, 1])

    # Top 15 - GRÃFICO MELHORADO (sem badges que tampam)
    top_brawlers = [b['Brawler'] for b in top_15]
    top_winrates = [b['Winrate'] for b in top_15]
    colors_top = plt.cm.Greens(np.linspace(0.5, 0.95, len(top_15)))

    bars1 = ax1.barh(range(len(top_15)), top_winrates, color=colors_top, edgecolor='white', linewidth=2)
    ax1.set_yticks(range(len(top_15)))
    ax1.set_yticklabels([f"#{i+1} {name}" for i, name in enumerate(top_brawlers)], fontsize=11, fontweight='bold')
    ax1.set_xlabel('Winrate (%)', fontsize=13, fontweight='bold')
    ax1.set_title(f'ðŸ† TOP 15 MELHORES - {mode_name.upper()}', fontsize=16, fontweight='bold', pad=20, color='#00ff88')
    ax1.grid(axis='x', alpha=0.3, linestyle='--')
    ax1.invert_yaxis()
    ax1.set_xlim(0, max(top_winrates) * 1.15)

    for i, (bar, brawler) in enumerate(zip(bars1, top_15)):
        width = bar.get_width()
        ax1.text(width + 0.5, bar.get_y() + bar.get_height()/2,
                f"{brawler['Winrate']:.2f}%",
                va='center', fontsize=10, fontweight='bold', color='white')

    # Bottom 15
    bottom_brawlers = [b['Brawler'] for b in bottom_15]
    bottom_winrates = [b['Winrate'] for b in bottom_15]
    colors_bottom = plt.cm.Reds(np.linspace(0.5, 0.95, len(bottom_15)))

    bars2 = ax2.barh(range(len(bottom_15)), bottom_winrates, color=colors_bottom, edgecolor='white', linewidth=2)
    ax2.set_yticks(range(len(bottom_15)))
    ax2.set_yticklabels([f"#{i+1} {name}" for i, name in enumerate(bottom_brawlers)], fontsize=11, fontweight='bold')
    ax2.set_xlabel('Winrate (%)', fontsize=13, fontweight='bold')
    ax2.set_title(f'ðŸ’€ TOP 15 PIORES - {mode_name.upper()}', fontsize=16, fontweight='bold', pad=20, color='#ff4444')
    ax2.grid(axis='x', alpha=0.3, linestyle='--')
    ax2.invert_yaxis()
    ax2.set_xlim(0, max(bottom_winrates) * 1.15 if bottom_winrates else 50)

    for i, (bar, brawler) in enumerate(zip(bars2, bottom_15)):
        width = bar.get_width()
        ax2.text(width + 0.5, bar.get_y() + bar.get_height()/2,
                f"{brawler['Winrate']:.2f}%",
                va='center', fontsize=10, fontweight='bold', color='white')

    # ===== TABELAS =====
    ax3 = fig.add_subplot(gs[1, 0])
    ax4 = fig.add_subplot(gs[1, 1])

    ax3.axis('off')
    ax4.axis('off')

    # Tabela Top 15
    table_data_top = [[f"#{i+1}", b['Brawler'], f"{b['Winrate']:.2f}%", f"{b['Batalhas']:,}", f"{b['Vitorias']:,}"]
                      for i, b in enumerate(top_15[:10])]  # Mostrar top 10 na tabela

    table_top = ax3.table(cellText=table_data_top,
                         colLabels=['Rank', 'Brawler', 'Winrate', 'Batalhas', 'VitÃ³rias'],
                         cellLoc='center',
                         loc='center',
                         bbox=[0, 0, 1, 1])

    table_top.auto_set_font_size(False)
    table_top.set_fontsize(10)
    table_top.scale(1, 2.5)

    # Estilizar tabela top
    for i in range(len(table_data_top) + 1):
        for j in range(5):
            cell = table_top[(i, j)]
            if i == 0:
                cell.set_facecolor('#00ff88')
                cell.set_text_props(weight='bold', color='black')
            else:
                cell.set_facecolor('#1a3a1a' if i % 2 == 0 else '#0d1d0d')
                cell.set_text_props(color='white')
            cell.set_edgecolor('white')
            cell.set_linewidth(1.5)

    ax3.set_title('ðŸ“Š TOP 10 - DADOS DETALHADOS', fontsize=13, fontweight='bold', pad=10, color='#00ff88')

    # Tabela Bottom 15
    table_data_bottom = [[f"#{i+1}", b['Brawler'], f"{b['Winrate']:.2f}%", f"{b['Batalhas']:,}", f"{b['Vitorias']:,}"]
                         for i, b in enumerate(bottom_15[:10])]

    table_bottom = ax4.table(cellText=table_data_bottom,
                            colLabels=['Rank', 'Brawler', 'Winrate', 'Batalhas', 'VitÃ³rias'],
                            cellLoc='center',
                            loc='center',
                            bbox=[0, 0, 1, 1])

    table_bottom.auto_set_font_size(False)
    table_bottom.set_fontsize(10)
    table_bottom.scale(1, 2.5)

    # Estilizar tabela bottom
    for i in range(len(table_data_bottom) + 1):
        for j in range(5):
            cell = table_bottom[(i, j)]
            if i == 0:
                cell.set_facecolor('#ff4444')
                cell.set_text_props(weight='bold', color='black')
            else:
                cell.set_facecolor('#3a1a1a' if i % 2 == 0 else '#1d0d0d')
                cell.set_text_props(color='white')
            cell.set_edgecolor('white')
            cell.set_linewidth(1.5)

    ax4.set_title('ðŸ“Š PIORES 10 - DADOS DETALHADOS', fontsize=13, fontweight='bold', pad=10, color='#ff4444')

    # ===== ESTATÃSTICAS =====
    ax5 = fig.add_subplot(gs[2, :])
    ax5.axis('off')

    stats_text = f"""
    ðŸ“Š ESTATÃSTICAS DO MODO: {mode_name.upper()}

    ðŸ† Melhor Performance: {top_15[0]['Brawler']} com {top_15[0]['Winrate']:.2f}% de winrate
    ðŸ’€ Pior Performance: {bottom_15[0]['Brawler']} com {bottom_15[0]['Winrate']:.2f}% de winrate
    ðŸ“ˆ DiferenÃ§a: {top_15[0]['Winrate'] - bottom_15[0]['Winrate']:.2f} pontos percentuais
    ðŸŽ® Total de Brawlers Analisados: {len(rankings['all'])} (mÃ­nimo 100 batalhas cada)
    """

    ax5.text(0.5, 0.5, stats_text, fontsize=12, ha='center', va='center',
             bbox=dict(boxstyle='round', facecolor='#1a1a2e', edgecolor='white', linewidth=2),
             color='white', fontweight='bold')

    plt.suptitle(f'ðŸŽ® ANÃLISE COMPLETA - {mode_name.upper()}',
                fontsize=18, fontweight='bold', y=0.98)

    filename = f"ranking_completo_{mode_name.replace(' ', '_').replace('-', '_').lower()}.png"
    plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='#0d1117')
    print(f"âœ… GrÃ¡fico salvo: {filename}")
    plt.show()

# ============================================================================
# GRÃFICO TOP 10 MAIS USADOS
# ============================================================================

print("\nðŸ“Š Gerando grÃ¡fico de brawlers mais usados...")

fig, ax = plt.subplots(figsize=(16, 10))

top_10_names = [b['Brawler'] for b in top_10_usage]
top_10_pickrates = [b['Pickrate'] for b in top_10_usage]
top_10_winrates = [b['Winrate'] for b in top_10_usage]

x = np.arange(len(top_10_names))
width = 0.35

bars1 = ax.bar(x - width/2, top_10_pickrates, width, label='Pickrate (%)',
               color='#00aaff', edgecolor='white', linewidth=2)
bars2 = ax.bar(x + width/2, top_10_winrates, width, label='Winrate (%)',
               color='#ff6b35', edgecolor='white', linewidth=2)

ax.set_xlabel('Brawlers', fontsize=13, fontweight='bold')
ax.set_ylabel('Porcentagem (%)', fontsize=13, fontweight='bold')
ax.set_title('ðŸ”¥ TOP 10 BRAWLERS MAIS USADOS - PICKRATE vs WINRATE',
            fontsize=16, fontweight='bold', pad=20)
ax.set_xticks(x)
ax.set_xticklabels(top_10_names, rotation=45, ha='right', fontsize=11, fontweight='bold')
ax.legend(fontsize=12, loc='upper right')
ax.grid(axis='y', alpha=0.3, linestyle='--')

# Adicionar valores nas barras
for bar in bars1:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2., height + 0.2,
            f'{height:.1f}%', ha='center', va='bottom', fontsize=9, fontweight='bold')

for bar in bars2:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2., height + 0.2,
            f'{height:.1f}%', ha='center', va='bottom', fontsize=9, fontweight='bold')

plt.tight_layout()
plt.savefig('top_10_mais_usados.png', dpi=300, bbox_inches='tight', facecolor='#0d1117')
print(f"âœ… GrÃ¡fico salvo: top_10_mais_usados.png")
plt.show()

# ============================================================================
# GRÃFICOS DE CLUSTER
# ============================================================================

print("\nðŸ“Š Gerando visualizaÃ§Ãµes de clusters...")

for mode_name in TARGET_MODES:
    if mode_name not in cluster_results:
        continue

    cluster_data = cluster_results[mode_name]
    brawlers = cluster_data['brawlers']

    fig, ax = plt.subplots(figsize=(14, 10))

    tier_colors = {'Top Tier': '#00ff88', 'Mid Tier': '#ffaa00', 'Low Tier': '#ff4444'}

    for tier, color in tier_colors.items():
        tier_brawlers = [b for b in brawlers if b['Tier'] == tier]
        if tier_brawlers:
            x = [b['Picks'] for b in tier_brawlers]
            y = [b['Winrate'] for b in tier_brawlers]
            ax.scatter(x, y, c=color, s=150, alpha=0.7, edgecolors='white', linewidth=2, label=tier)

    ax.set_xlabel('Total de Picks (Uso)', fontsize=13, fontweight='bold')
    ax.set_ylabel('Winrate (%)', fontsize=13, fontweight='bold')
    ax.set_title(f'ðŸ¤– CLUSTERIZAÃ‡ÃƒO K-MEANS - {mode_name.upper()}',
                fontsize=15, fontweight='bold', pad=20)
    ax.legend(fontsize=12, loc='best', framealpha=0.9)
    ax.grid(alpha=0.3, linestyle='--')

    plt.tight_layout()
    filename = f"cluster_{mode_name.replace(' ', '_').replace('-', '_').lower()}.png"
    plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='#0d1117')
    print(f"âœ… Cluster salvo: {filename}")
    plt.show()

# ============================================================================
# SALVAR EXCEL
# ============================================================================

print("\n" + "="*70)
print("ðŸ’¾ SALVANDO EXCEL COMPLETO...")
print("="*70)

excel_output = 'analise_completa_brawl_stars.xlsx'

with pd.ExcelWriter(excel_output, engine='openpyxl') as writer:
    # Aba 0: Top 10 Mais Usados
    df_usage = pd.DataFrame(top_10_usage)
    df_usage.index = range(1, len(df_usage) + 1)
    df_usage.to_excel(writer, sheet_name='TOP_10_Mais_Usados', index_label='Rank')

    # Abas por modo
    for mode_name in TARGET_MODES:
        if mode_name not in all_rankings:
            continue

        rankings = all_rankings[mode_name]

        # Top 15
        df_top = pd.DataFrame(rankings['top_15'])
        df_top.index = range(1, len(df_top) + 1)
        sheet_name = f"TOP_{mode_name.replace(' ', '_').replace('-', '_')}"[:31]
        df_top.to_excel(writer, sheet_name=sheet_name, index_label='Rank')

        # Bottom 15
        df_bottom = pd.DataFrame(rankings['bottom_15'])
        df_bottom.index = range(1, len(df_bottom) + 1)
        sheet_name = f"PIOR_{mode_name.replace(' ', '_').replace('-', '_')}"[:31]
        df_bottom.to_excel(writer, sheet_name=sheet_name, index_label='Rank')

        # Todos com clusters
        if mode_name in cluster_results:
            df_all = pd.DataFrame(cluster_results[mode_name]['brawlers'])
        else:
            df_all = pd.DataFrame(rankings['all'])

        sheet_name = f"ALL_{mode_name.replace(' ', '_').replace('-', '_')}"[:31]
        df_all.to_excel(writer, sheet_name=sheet_name, index=False)

print(f"âœ… Excel salvo: {excel_output}")

# ============================================================================
# RESUMO FINAL
# ============================================================================

print("\n" + "="*70)
print("ðŸ“Š RESUMO FINAL DA ANÃLISE")
print("="*70)

print(f"\nðŸ”¥ TOP 3 BRAWLERS MAIS USADOS:")
for i, b in enumerate(top_10_usage[:3], 1):
    print(f"   {i}. {b['Brawler']} - {b['Pickrate']:.2f}% de pickrate")

print(f"\nðŸ† MELHORES POR MODO:")
for mode_name in TARGET_MODES:
    if mode_name in all_rankings:
        best = all_rankings[mode_name]['top_15'][0]
        print(f"   {mode_name}: {best['Brawler']} ({best['Winrate']:.2f}%)")

print(f"\nðŸ’€ PIORES POR MODO:")
for mode_name in TARGET_MODES:
    if mode_name in all_rankings:
        worst = all_rankings[mode_name]['bottom_15'][0]
        print(f"   {mode_name}: {worst['Brawler']} ({worst['Winrate']:.2f}%)")

print("\n" + "="*70)
print("âœ… ANÃLISE COMPLETA FINALIZADA!")
print("="*70)
print("\nðŸ“ Arquivos gerados:")
print("   - 6 grÃ¡ficos completos (ranking + tabelas + stats)")
print("   - 1 grÃ¡fico top 10 mais usados")
print("   - 6 grÃ¡ficos de clusterizaÃ§Ã£o K-Means")
print("   - 1 Excel com 19 abas")
print("\nðŸŽ‰ Use os dados para dominar o meta!")
print("="*70)

# LOGREG_PIPELINE_COMPATIBLE.py
# Executar no Colab - cÃ©lula Ãºnica.
# Requisitos: pandas, scikit-learn, joblib, openpyxl (jÃ¡ instalados pelo seu setup anterior).

import os, json, joblib, random, math, warnings
from collections import defaultdict
import numpy as np
import pandas as pd

from sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.calibration import CalibratedClassifierCV
from sklearn.metrics import roc_auc_score, log_loss, brier_score_loss, accuracy_score
from sklearn.impute import SimpleImputer

warnings.filterwarnings("ignore")

# ----------------- CONFIG -----------------
DATA_FOLDER = "/content/drive/MyDrive/BrawlStarsData_1M"  # ajuste se necessÃ¡rio
MATCHES_CSV = os.path.join(DATA_FOLDER, "matches.csv")   # se existir, preferimos este arquivo (linhas por partida)
MODEL_OUT = os.path.join(DATA_FOLDER, "logreg_brawl_model_pack.joblib")
RANDOM_STATE = 42
MIN_BATTLES_PER_PAIR = 30   # filtra pares brawler+mode com poucos dados
MAX_SAMPLES_PER_PAIR = 2000 # para proxy (limita memÃ³ria)
# ------------------------------------------

# Localiza JSON agregado mais recente
json_files = [f for f in os.listdir(DATA_FOLDER) if f.endswith('.json')]
if not json_files:
    raise FileNotFoundError(f"Nenhum .json encontrado em {DATA_FOLDER}. Rode o pipeline de coleta antes.")
json_path = os.path.join(DATA_FOLDER, sorted(json_files)[-1])
print("Usando JSON agregado:", os.path.basename(json_path))

with open(json_path, 'r', encoding='utf-8') as f:
    agg = json.load(f)

mode_stats = agg.get('mode_stats', {})
brawler_stats_agg = agg.get('brawler_stats', {})

# ----------------- FUNÃ‡ÃƒO AUX: contar itens -----------------
def count_items(obj):
    try:
        return len(obj)
    except:
        return 0

# ----------------- Verifica se existe matches.csv -----------------
if os.path.exists(MATCHES_CSV):
    print("Arquivo matches.csv encontrado â€” usando dados de partidas reais (B1).")
    df = pd.read_csv(MATCHES_CSV)
    # normalize column names
    df.columns = [c.strip() for c in df.columns]
    # detect result column
    if 'result' not in df.columns:
        # tenta encontrar coluna semelhante
        candidates = [c for c in df.columns if any(w in c.lower() for w in ['result','outcome','win','victory'])]
        if candidates:
            df = df.rename(columns={candidates[0]: 'result'})
        else:
            raise ValueError("Arquivo matches.csv precisa ter coluna 'result' (win/loss).")
    # garantir colunas mÃ­nimas
    if 'brawler' not in df.columns or 'mode' not in df.columns:
        raise ValueError("Arquivo matches.csv precisa de colunas 'brawler' e 'mode' (nomes exatos).")
    # normaliza resultado
    df['is_win'] = df['result'].apply(lambda x: 1 if str(x).lower() in ['win','victory','vitoria','vitÃ³ria','1','true','t'] else 0)
    training_df = df[['brawler','mode','is_win']].copy()
    # adicional: se jÃ¡ tiver colunas de estatÃ­sticas por linha (kills,deaths...), vocÃª pode mantÃª-las
    # vamos agregar para features
    print("Total linhas (jogador-por-partida):", len(training_df))
    # cria agregados a partir das partidas reais
    b_stats = training_df.groupby('brawler')['is_win'].agg(['mean','count']).reset_index().rename(columns={'mean':'brawler_winrate','count':'brawler_games'})
    bm_stats = training_df.groupby(['brawler','mode'])['is_win'].agg(['mean','count']).reset_index().rename(columns={'mean':'bm_winrate','count':'bm_games'})

    # mesclar agregados no dataframe (enriquecer)
    training_df = training_df.merge(b_stats, on='brawler', how='left')
    training_df = training_df.merge(bm_stats, on=['brawler','mode'], how='left')
    training_df['bm_winrate'] = training_df['bm_winrate'].fillna(training_df['brawler_winrate'])
    training_df['bm_games'] = training_df['bm_games'].fillna(0)

    # adiciona metadata por brawler a partir do agg (star/gadget counts etc.)
    agg_brawlers = pd.DataFrame.from_dict(brawler_stats_agg, orient='index').reset_index().rename(columns={'index':'brawler'})
    agg_brawlers['n_star_powers'] = agg_brawlers['star_powers'].apply(lambda x: count_items(x) if isinstance(x, dict) else 0)
    agg_brawlers['n_gadgets'] = agg_brawlers['gadgets'].apply(lambda x: count_items(x) if isinstance(x, dict) else 0)
    agg_brawlers = agg_brawlers[['brawler','n_star_powers','n_gadgets','battles','picks']].rename(columns={'battles':'total_battles_global','picks':'total_picks_global'})

    training_df = training_df.merge(agg_brawlers, on='brawler', how='left')
    training_df['n_star_powers'] = training_df['n_star_powers'].fillna(0)
    training_df['n_gadgets'] = training_df['n_gadgets'].fillna(0)
    training_df['total_battles_global'] = training_df['total_battles_global'].fillna(0)
    # final dataset
    df_final = training_df.copy()

else:
    # fallback: gera dataset proxy a partir dos agregados (B2)
    print("Arquivo matches.csv NÃƒO encontrado â€” gerando dataset proxy a partir do JSON agregado (B2).")
    rows = []
    for mode, bdict in mode_stats.items():
        for bname, st in bdict.items():
            battles = int(st.get('battles', 0))
            wins = int(st.get('wins', 0))
            if battles < MIN_BATTLES_PER_PAIR:
                continue
            n_samples = min(battles, MAX_SAMPLES_PER_PAIR)
            p = wins / battles if battles > 0 else 0.5
            n_wins = int(round(p * n_samples))
            # append ones and zeros
            rows.extend([{'brawler': bname, 'mode': mode, 'is_win': 1}] * n_wins)
            rows.extend([{'brawler': bname, 'mode': mode, 'is_win': 0}] * (n_samples - n_wins))
    df_proxy = pd.DataFrame(rows).sample(frac=1, random_state=RANDOM_STATE).reset_index(drop=True)
    print("Total linhas geradas (proxy):", len(df_proxy))

    # agrega como antes
    b_stats = df_proxy.groupby('brawler')['is_win'].agg(['mean','count']).reset_index().rename(columns={'mean':'brawler_winrate','count':'brawler_games'})
    bm_stats = df_proxy.groupby(['brawler','mode'])['is_win'].agg(['mean','count']).reset_index().rename(columns={'mean':'bm_winrate','count':'bm_games'})
    df_proxy = df_proxy.merge(b_stats, on='brawler', how='left')
    df_proxy = df_proxy.merge(bm_stats, on=['brawler','mode'], how='left')
    df_proxy['bm_winrate'] = df_proxy['bm_winrate'].fillna(df_proxy['brawler_winrate'])
    df_proxy['bm_games'] = df_proxy['bm_games'].fillna(0)

    # add agg meta
    agg_brawlers = pd.DataFrame.from_dict(brawler_stats_agg, orient='index').reset_index().rename(columns={'index':'brawler'})
    agg_brawlers['n_star_powers'] = agg_brawlers['star_powers'].apply(lambda x: count_items(x) if isinstance(x, dict) else 0)
    agg_brawlers['n_gadgets'] = agg_brawlers['gadgets'].apply(lambda x: count_items(x) if isinstance(x, dict) else 0)
    agg_brawlers = agg_brawlers[['brawler','n_star_powers','n_gadgets','battles','picks']].rename(columns={'battles':'total_battles_global','picks':'total_picks_global'})
    df_proxy = df_proxy.merge(agg_brawlers, on='brawler', how='left')
    df_proxy['n_star_powers'] = df_proxy['n_star_powers'].fillna(0)
    df_proxy['n_gadgets'] = df_proxy['n_gadgets'].fillna(0)
    df_proxy['total_battles_global'] = df_proxy['total_battles_global'].fillna(0)

    df_final = df_proxy.copy()

# ----------------- Features / Target -----------------
# Categoricals and numerics
CAT = ['brawler','mode']
NUM = ['brawler_winrate','brawler_games','bm_winrate','bm_games','n_star_powers','n_gadgets','total_battles_global']
TARGET = 'is_win'

# Reduce memory: convert to appropriate dtypes
for col in NUM:
    df_final[col] = pd.to_numeric(df_final[col], errors='coerce').fillna(0)

X = df_final[CAT + NUM]
y = df_final[TARGET].astype(int)

print("Dataset pronto â€” shape:", X.shape)

# ----------------- Preprocessor with OneHotEncoder compatibility -----------------
from sklearn.pipeline import Pipeline as SKPipeline
from sklearn.impute import SimpleImputer

# Compatibilidade OHE: tenta sparse_output (novo), depois sparse (antigo), depois sem parÃ¢metro
try:
    ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
except TypeError:
    try:
        ohe = OneHotEncoder(handle_unknown='ignore', sparse=False)
    except TypeError:
        ohe = OneHotEncoder(handle_unknown='ignore')

num_pipeline = SKPipeline([
    ('imp', SimpleImputer(strategy='median')),
    ('sc', StandardScaler())
])

preprocessor = ColumnTransformer([
    ('cat', ohe, CAT),
    ('num', num_pipeline, NUM)
])

# ----------------- Train/Test split -----------------
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, stratify=y, random_state=RANDOM_STATE)
print("Train/test split:", X_train.shape, X_test.shape)

# ----------------- Pipeline e GridSearch -----------------
pipe = Pipeline([
    ('pre', preprocessor),
    ('clf', LogisticRegression(solver='saga', max_iter=2000, random_state=RANDOM_STATE))
])

param_grid = {
    'clf__C': [0.1, 1.0, 5.0],
    'clf__penalty': ['l2']
}

cv = StratifiedKFold(n_splits=4, shuffle=True, random_state=RANDOM_STATE)
grid = GridSearchCV(pipe, param_grid, cv=cv, scoring='roc_auc', n_jobs=-1, verbose=1)
print("Iniciando GridSearchCV (pode demorar dependendo do dataset)...")
grid.fit(X_train, y_train)

print("Melhor params:", grid.best_params_)
best_pipe = grid.best_estimator_

# ----------------- CalibraÃ§Ã£o -----------------
print("Treinando calibrador (isotonic)...")
calibrator = CalibratedClassifierCV(best_pipe, cv=3, method='isotonic')
calibrator.fit(X_train, y_train)
model_final = calibrator

# ----------------- AvaliaÃ§Ã£o -----------------
y_proba = model_final.predict_proba(X_test)[:,1]
auc = roc_auc_score(y_test, y_proba)
ll = log_loss(y_test, y_proba)
brier = brier_score_loss(y_test, y_proba)
acc = accuracy_score(y_test, (y_proba >= 0.5).astype(int))

print(f"\nMÃ©tricas no test set:\n AUC = {auc:.4f}\n LogLoss = {ll:.4f}\n Brier = {brier:.4f}\n Accuracy(0.5) = {acc:.4f}")

# ----------------- Salvar modelo e artefatos (pack) -----------------
# Salvamos: modelo calibrado, agregados (agg), b_stats e bm_stats (para enriquecer preds), col listas
pack = {
    'model': model_final,
    'agg_json_path': json_path,
    'agg': agg,
    'b_stats': b_stats if 'b_stats' in locals() else None,
    'bm_stats': bm_stats if 'bm_stats' in locals() else None,
    'features': {'CAT': CAT, 'NUM': NUM}
}

joblib.dump(pack, MODEL_OUT, compress=3)
print("Modelo e artefatos salvos em:", MODEL_OUT)

# ----------------- FunÃ§Ã£o utilitÃ¡ria de prediÃ§Ã£o (usa agregados salvos) -----------------
def predict_win_probability(brawler, mode, model_path=MODEL_OUT):
    """
    Retorna dict: {'brawler','mode','p_win','confidence_pct'}
    Usa os agregados do pack para preencher features; faz fallback para valores neutros.
    """
    pack = joblib.load(model_path)
    model = pack['model']
    agg = pack.get('agg', {})
    # preparar linha de entrada
    # default values
    row = {
        'brawler': brawler,
        'mode': mode,
        'brawler_winrate': 0.5,
        'brawler_games': 0,
        'bm_winrate': 0.5,
        'bm_games': 0,
        'n_star_powers': 0,
        'n_gadgets': 0,
        'total_battles_global': 0
    }
    # pegar meta de brawler a partir do agg (brawler_stats)
    bmeta = agg.get('brawler_stats', {}).get(brawler, None)
    if bmeta:
        b_battles = bmeta.get('battles', 0)
        b_wins = bmeta.get('wins', 0)
        row['brawler_winrate'] = (b_wins / b_battles) if b_battles>0 else 0.5
        row['brawler_games'] = b_battles
        row['n_star_powers'] = count_items(bmeta.get('star_powers', {})) if isinstance(bmeta.get('star_powers', None), dict) else 0
        row['n_gadgets'] = count_items(bmeta.get('gadgets', {})) if isinstance(bmeta.get('gadgets', None), dict) else 0
        row['total_battles_global'] = b_battles
    # pegar bm (brawler+mode) stats do agg->mode_stats se possÃ­vel
    mode_dict = agg.get('mode_stats', {}).get(mode, {})
    if mode_dict:
        bm = mode_dict.get(brawler, {})
        if bm:
            bm_battles = bm.get('battles', 0)
            bm_wins = bm.get('wins', 0)
            row['bm_winrate'] = (bm_wins / bm_battles) if bm_battles>0 else row['brawler_winrate']
            row['bm_games'] = bm_battles
    # construir DataFrame de input
    X_in = pd.DataFrame([row])[pack['features']['CAT'] + pack['features']['NUM']]
    # model espera DataFrame com col names; pipeline faz o restante
    proba = model.predict_proba(X_in)[:,1][0]
    return {'brawler': brawler, 'mode': mode, 'p_win': float(round(proba, 4)), 'confidence_pct': float(round(proba*100,2))}

# ----------------- Exemplo rÃ¡pido -----------------
print("\nExemplo de prediÃ§Ã£o (troque para brawler/mode do seu interesse):")
example_brawler = next(iter(brawler_stats_agg.keys()))  # pega 1 brawler do agregado
example_mode = next(iter(mode_stats.keys())) if mode_stats else "Futebraw"
print("Exemplo usado:", example_brawler, "|", example_mode)
print(predict_win_probability(example_brawler, example_mode, MODEL_OUT))

print("\nTudo pronto â€” use predict_win_probability(brawler, mode) para consultar probabilidades.")

predict_win_probability("SHELLY", "Nocaute")

# PLOT_PWIN_WITH_MEAN.py
# Gera grÃ¡ficos por modo: cada brawler (p_win%) e uma linha vertical indicando a mÃ©dia do modo.
# Requisitos: joblib, pandas, matplotlib, seaborn, google.colab.drive montado.

import os, joblib, json, math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive

# -------- CONFIG --------
DATA_FOLDER = "/content/drive/MyDrive/BrawlStarsData_1M"   # ajuste se necessÃ¡rio
OUT_PLOT_FOLDER = os.path.join(DATA_FOLDER, "plots_pwin_with_mean")
MAX_BARS_PER_PLOT = 80   # se modo tiver >80 brawlers, reduz fonte/tamanho
FIG_DPI = 160
# ------------------------

os.makedirs(OUT_PLOT_FOLDER, exist_ok=True)

# monta drive (se necessÃ¡rio)
try:
    drive.mount('/content/drive', force_remount=False)
except Exception as e:
    # provavelmente jÃ¡ montado
    pass

# localizar JSON agregado e modelo
json_files = [f for f in os.listdir(DATA_FOLDER) if f.endswith('.json')]
if not json_files:
    raise FileNotFoundError("Nenhum .json encontrado em DATA_FOLDER.")
json_path = os.path.join(DATA_FOLDER, sorted(json_files)[-1])

joblib_files = [f for f in os.listdir(DATA_FOLDER) if f.endswith('.joblib')]
if not joblib_files:
    raise FileNotFoundError("Nenhum .joblib encontrado em DATA_FOLDER (modelo salvo).")
model_path = os.path.join(DATA_FOLDER, sorted(joblib_files)[-1])

print("Usando JSON:", os.path.basename(json_path))
print("Usando modelo:", os.path.basename(model_path))

# carregar
with open(json_path, 'r', encoding='utf-8') as f:
    agg = json.load(f)

pack = joblib.load(model_path)
if isinstance(pack, dict) and 'model' in pack:
    model = pack['model']
    features_info = pack.get('features', None)
    agg_in_pack = pack.get('agg', agg)
else:
    model = pack
    features_info = None
    agg_in_pack = agg

mode_stats = agg_in_pack.get('mode_stats', {})
brawler_stats_agg = agg_in_pack.get('brawler_stats', {})

# helper
def count_items(obj):
    try:
        return len(obj)
    except:
        return 0

# build input rows for all pairs
rows = []
for mode in mode_stats.keys():
    for b in brawler_stats_agg.keys():
        row = {
            'brawler': b,
            'mode': mode,
            'brawler_winrate': 0.5,
            'brawler_games': 0,
            'bm_winrate': 0.5,
            'bm_games': 0,
            'n_star_powers': 0,
            'n_gadgets': 0,
            'total_battles_global': 0
        }
        bmeta = brawler_stats_agg.get(b, {})
        if bmeta:
            b_battles = bmeta.get('battles', 0)
            b_wins = bmeta.get('wins', 0)
            row['brawler_winrate'] = (b_wins / b_battles) if b_battles > 0 else 0.5
            row['brawler_games'] = b_battles
            row['n_star_powers'] = count_items(bmeta.get('star_powers', {})) if isinstance(bmeta.get('star_powers', None), dict) else 0
            row['n_gadgets'] = count_items(bmeta.get('gadgets', {})) if isinstance(bmeta.get('gadgets', None), dict) else 0
            row['total_battles_global'] = b_battles
        bm = mode_stats.get(mode, {}).get(b, {})
        if bm:
            bm_battles = bm.get('battles', 0)
            bm_wins = bm.get('wins', 0)
            row['bm_winrate'] = (bm_wins / bm_battles) if bm_battles > 0 else row['brawler_winrate']
            row['bm_games'] = bm_battles
        rows.append(row)

df_all = pd.DataFrame(rows)

# features expected
if features_info and isinstance(features_info, dict):
    CAT = features_info.get('CAT', ['brawler','mode'])
    NUM = features_info.get('NUM', ['brawler_winrate','brawler_games','bm_winrate','bm_games','n_star_powers','n_gadgets','total_battles_global'])
else:
    CAT = ['brawler','mode']
    NUM = ['brawler_winrate','brawler_games','bm_winrate','bm_games','n_star_powers','n_gadgets','total_battles_global']

X_all = df_all[CAT + NUM]

# predict probabilities (classe 1 = win)
print("Gerando probabilidades (p_win) â€” aguarde...")
if hasattr(model, 'predict_proba'):
    probs = model.predict_proba(X_all)[:,1]
else:
    probs = model.predict(X_all)

df_all['p_win'] = probs
df_all['p_win_pct'] = df_all['p_win'] * 100

# calculo da mÃ©dia por modo
mode_stats_df = df_all.groupby('mode')['p_win_pct'].agg(['mean','std','count']).rename(columns={'mean':'mode_mean_pct','std':'mode_std_pct','count':'n_brawlers'}).reset_index()
df_all = df_all.merge(mode_stats_df, on='mode', how='left')
df_all['above_mean'] = df_all['p_win_pct'] > df_all['mode_mean_pct']

# configura visual
sns.set(style="whitegrid")
for mode in sorted(df_all['mode'].unique()):
    sub = df_all[df_all['mode']==mode].copy()
    if sub.empty:
        continue
    # ordenar por p_win
    sub = sub.sort_values('p_win_pct', ascending=True)
    n = len(sub)
    figsize = (12, max(5, n*0.12))  # ajusta altura conforme nÂº brawlers
    plt.figure(figsize=figsize, dpi=FIG_DPI)
    colors = sub['above_mean'].map({True: '#2ecc71', False: '#e74c3c'}).tolist()  # verde acima, vermelho abaixo
    bars = plt.barh(range(n), sub['p_win_pct'], color=colors, edgecolor='white', height=0.7)
    plt.yticks(range(n), sub['brawler'], fontsize=9)
    plt.xlabel('Probabilidade de vitÃ³ria (%)', fontsize=11, fontweight='bold')
    plt.title(f'Probabilidade de vitÃ³ria por Brawler â€” {mode}', fontsize=14, fontweight='bold')
    # mean line
    mean_pct = sub['mode_mean_pct'].iloc[0]
    plt.axvline(mean_pct, color='gold', linestyle='--', linewidth=2, label=f'MÃ©dia do modo: {mean_pct:.2f}%')
    # annotate numbers
    for i, (idx, row) in enumerate(sub.iterrows()):
        val = row['p_win_pct']
        plt.text(val + 0.4, i, f"{val:.2f}%", va='center', fontsize=8)
    plt.legend(loc='lower right')
    plt.tight_layout()
    fname = os.path.join(OUT_PLOT_FOLDER, f"pwin_bar_with_mean_{mode.replace(' ','_').replace('/','_')}.png")
    plt.savefig(fname, bbox_inches='tight')
    plt.show()
    plt.close()
    print("GrÃ¡fico salvo:", fname)

print("\nâœ… Todos os grÃ¡ficos salvos em:", OUT_PLOT_FOLDER)
print("Dica: abra os PNGs ali ou visualize no notebook. A linha amarela mostra a mÃ©dia do modo â€” barras verdes = acima da mÃ©dia, vermelhas = abaixo.")

predict_win_probability("KAZE", "Nocaute")